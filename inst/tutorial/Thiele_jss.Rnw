\documentclass[article]{jss}

\usepackage{longtable}
\usepackage{lscape}
\usepackage{caption}

\graphicspath{{images/}}

%% version info: 
%%     September, 02, 2013
%%     for RNetLogo 0.9.6 and NetLogo 5.0.4


%% almost as usual
\author{
  Jan C. Thiele\\
  Department of\\
  Ecoinformatics, Biometrics\\
  and Forest Growth\\
  University of G\"ottingen\\
  Germany
}
\title{\proglang{R} Marries \proglang{NetLogo}: \\ Introduction to the \pkg{RNetLogo} Package}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Jan C. Thiele} %% comma-separated
\Plaintitle{R Marries NetLogo: Introduction to the RNetLogo Package} %% without formatting
\Shorttitle{R Marries NetLogo} %% a short title (if necessary)

%% an abstract and keywords
\Abstract{
The \pkg{RNetLogo} package delivers an interface to embed the agent-based modeling platform \proglang{NetLogo} into the 
\proglang{R} environment with headless (no Graphical User Interface) or interactive GUI mode. 
It provides functions to load models, execute commands, push values, and to get 
values from \proglang{NetLogo} reporters. Such a seamless integration of a widely used agent-based modeling platform with
a well-known statistical computing and graphics environment opens various possibilities. For example, it enables the modeler to design simulation experiments, store simulation results, and analyze simulation output in a more systematic way. It can therefore help close the gaps in agent-based modeling regarding standards of description and analysis. After a short overview of the agent-based modeling approach and the software used here, the paper delivers a step-by-step introduction to the usage of the \pkg{RNetLogo} package by examples. 
}
\Keywords{\proglang{NetLogo}, \proglang{R}, agent based modeling, ABM, 
individual based modeling, IBM, statistics, graphics}
\Plainkeywords{NetLogo, R, agent based modeling, abm, 
individual based modeling, ibm, statistics, graphics} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Jan C. Thiele\\
  Department of Ecoinformatics, Biometrics and Forest Growth\\
  University of G\"ottingen\\
  B\"usgenweg 4\\
  37077 G\"ottingen, Germany\\
  E-mail: \email{jthiele@gwdg.de}\\
  URL: \url{http://www.uni-goettingen.de/en/72779.html}\\
}

%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/1/31336-5053
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\SweaveOpts{concordance=FALSE}
\SweaveOpts{engine = R, eps = FALSE}
\SweaveOpts{keep.source = TRUE}
\SweaveOpts{prefix.string=C:/Users/jthiele/Documents/Projects/RNetLogo/jss/images/}

<<label=preliminaries_hidden, echo=FALSE, results=hide>>=
options(prompt = "R> ", continue = "+  ", width = 70, useFancyQuotes = FALSE)
# a hidden database path used for Application Examples
base.path <- "C:/Users/jthiele/Documents/Projects/RNetLogo/jss"
database.path.hidden = paste(base.path, "test_netlogo.db", sep="/")
@
\fvset{listparameters={\setlength{\topsep}{0pt}}}
\renewenvironment{Schunk}{\vspace{\topsep}}{\vspace{\topsep}}


\maketitle

\section[Introduction]{Introduction}
\label{sec:intro}

\subsection[Agent- and individual-based modeling]{Agent- and individual-based modeling}
\label{sec:agentBasedModeling}

Agent-based models (ABMs) or individual-based models (IBMs), as they are called in ecology and biology, are simulation models that explicitly represent individual agents, which can be, for example, humans, institutions, or organisms with their traits and behavior \citep{Grimm2005, Gilbert2008, Thiele2011}. A key characteristic of this modeling approach is that simulation results emerge from the more or less complex interactions among the agents. Therefore, such models are useful when local interactions on the micro level are essential for the description of patterns on the macro level. 

The origins of the ABM approach go back to the late 1970s \citep[e.g.,][]{Hewitt1976} with the development of so-called multi-agent systems (MAS) in computer science as a part of the distributed artificial intelligence (DAI) research area \citep{Green1997, Sycara1998}. Their wider use in computer science began only in the 1990s \citep{Luck2003, Wooldridge2002,  Weiss1999}. Definitions of the term MAS and what an agent is, can be found for example in \citet{Wooldridge2002} and \citet{Jennings1999}. Examples for the use of MAS with intelligent agents in the field of computer science include computer games, computer networks, robotics for manufacturing, and traffic-control systems \citep[for examples, see][]{Oliveira1999, Luck2003, Shen2006, Moonen2009}. 

With increasing importance of questions about coordination and cooperation within the MAS the connections to social sciences arose \citep{Conte1998} and the field of agent-based social simulation (ABSS), that is, an agent-based modeling approach as part of computational sociology became a 'counter-concept' to the classical top-down system dynamics and microsimulation approaches \citep{Gilbert1999, Squazzoni2010}. ABSS is mainly used for theory testing and development \citep{Macy2002, Conte2006} and applied to simulations of differentiation, diffusion, and emergence of social order in social systems \citep[for examples, see listings in][]{Macy2002, Squazzoni2010} as well as to questions about demographic behavior \citep{Billari2003}. The most famous models in social sciences are Schelling's segregation model \citep{Schelling1969} and the Sugarscape model of \citet{Epstein1996}. 

Strongly related to the development of ABMs in social sciences is the establishment of the ABM approach in economics, which is called agent-based computational economics (ACE) and related to the field of cognitive and evolutionary economics. The aims of ACE can be divided into four categories: empirical understanding, normative understanding, qualitative insight as well as theory generation and methodological advancement \citep[for details, see][]{ Tesfatsion2006}. It was applied, for example, to the reproduction of the classical cobweb theorem \citep[e.g.,][]{Arifovic1994}, to model financial/stock markets \citep[see][for a review]{LeBaron2000} as well as to the simulation of industry and labor dynamics \citep[e.g.,][]{Leombruni2004}. 

In contrast to ABSS and ACE, the agent-based modeling approach has a slightly longer tradition in ecology \citep{Grimm2005}. The development of so called individual-based models is less closely related to the developments of MAS, because ecologists early became aware of the restrictions in classical population models (differential equation models) and looked for alternatives. Over the last three to four decades hundreds of IBMs were developed in ecology \citep{DeAngelis2005}. For reviews see, for example, \citet{Grimm1999} and \citet{DeAngelis2005}. 

Besides these four main research areas, there are many other disciplines in which ABMs are increasingly used, often within an interdisciplinary context. Examples include ecological economics \citep[e.g.,][]{Heckbert2010}, marketing/socio-psychology \citep[e.g.,][]{North2010}, archaeology/anthropology \citep[e.g.,][]{Griffin2007}, microbiology \citep[e.g.,][]{Ferrer2008}, biomedicine/epidemiology \citep[e.g.,][]{Carpenter2009}, criminology \citep[strongly related to ABSS, e.g.,][]{Malleson2010} and land-use management \citep[e.g.,][]{Matthews2007}.

\subsection[Links to statistics]{Links to statistics}
\label{sec:statistics}

Links to statistics can be found in agent-based modeling along nearly all stages of the modeling cycle. Often, models are developed on the basis of empirical/field data. This gives the first link to statistics as data are analyzed with statistical methods to derive patterns, fit regression models and so on to construct and parameterize the rules and to prepare input as well as validation data. 

Often, agent-based model rules depend on statistical methods applied during a simulation run. In very easy cases, for example, animal reproduction could depend on the sum of the food intake in a certain period but it is also possible for agent behaviors to be based on correlation, regression, network, point pattern analysis etc.  

The third link comes into play when the model is formulated and implemented and some parameters of the model are unknown. Then, methods of inverse modeling with different sampling schemes, Bayesian calibration, genetic algorithms and so on can be used to obtain feasible parameter values. 

In the next stage, the model application, methods like uncertainty and sensitivity analysis provide important tools to gain an understanding of the systems' behavior and functioning, i.e. to open the black box of complexity. 

The last link to statistics is the further analysis of the model output using descriptive as well as inferential statistics. Depending on the type of model, this can include correlation analysis, hypothesis testing, network analysis, spatial statistics, time series analysis, survival analysis etc. 

The focus in this article is on those parts where statistical methods are applied in combination with the model runs. 
%This comes into account from the third link on. 
%In parameter fitting, depending on the method, one tested parameter set can depend on the result of the former parameter set. The model runs are therefore not indepented, for example in Genertic algorithms and Baysian calibration, and cannot be processed in a batch process with predefined parameter sets. 
 
\subsection[NetLogo]{\proglang{NetLogo}}
\label{sec:netlogo}

Wilensky's \proglang{NetLogo} \citep{Wilensky1999} is an agent-based modeling tool developed and maintained since 1999 by the Center for Connected Learning and Computer-based Modeling at Northwestern University, Illinois. It is an open-source software platform programmed in Java and Scala especially 
designed for the development of agent-based simulation models and comes with an integrated development
and simulation environment. It provides many predefined methods (so-called primitives and reporters) for behavioral rules of the agents.  Because it has a Logo-like syntax and standard agent types (turtles, patches, links), in combination with a built-in GUI, it is very easy to learn. Due to its simplicity and relatively large user community, it is becoming the standard platform for communicating and implementing ABMs that previously has been lacking.

For an introduction into \proglang{NetLogo} see its documentation \url{http://ccl.northwestern.edu/netlogo/docs/}. An introduction into agent-based modeling using \proglang{NetLogo} can be 
found, for example, in \citet{Railsback2011} or \citet{Wilensky2011}.

\subsection[R]{\proglang{R}}
\label{sec:r}

\proglang{R} \citep{Rcore2013a} is a well-known and established language and open source environment for statistical 
computing and graphics with many user-contributed packages. 

For \proglang{NetLogo} users not yet familiar with \proglang{R}: \proglang{R} is very well documented; see, for example, the \proglang{R} language definition \citep{Rcore2013b}. 
Furthermore, many tutorials can be found in the web, for example, \citet{Maindonald2008, Venables2011, QR2011, Owen2010}; and many books are available, for example, \citet{Zuur2009, Crawley2005, Kabacoff2010, VenablesRipley2002}.
 
\subsection[Notes]{Note on this article}
\label{sec:notes}

This work is a mixture of scientific article and tutorial for a scientific tool; writing styles differ between these two elements, but section headings indicate what element each section contains.

\section[Introducing RNetLogo]{Introducing \pkg{RNetLogo}}
\label{sec:rnetLogo}

\pkg{RNetLogo} is an \proglang{R} package that links \proglang{R} and \proglang{NetLogo}; i.e., any \proglang{NetLogo} model can be run and controlled from \proglang{R} and simulation results can be transferred back to \proglang{R} for statistical analyses. This is desirable as \proglang{NetLogo}'s support of systematic design, performance, and analysis of simulation experiments is limited. In general, much more could be learned from ABMs if they were embedded in a  rigorous  framework  for  designing  simulation  experiments  \citep{Oh2009},  storing simulation  results  in  a  systematic  way,  and  using  statistical  toolboxes  for  analysing  these results. \pkg{RNetLogo} can be used to bridge this gap since \proglang{R} (and the enormous number of packages) delivers such tools. 
Such a seamless integration  was  already the scope of \proglang{NetLogo}'s \pkg{Mathematica Link} \citep{Bakshy2007b}, which was designed to make use of \proglang{Mathematica}'s  functionality  for  'advanced  import  capabilities,  statistical  functions,  data visualization, and document creation. With \proglang{NetLogo}'s \pkg{Mathematica Link}, you can run all of these tools side-by-side with \proglang{NetLogo}' \citep{Bakshy2007}. \pkg{RNetLogo} offers such a framework for two freely available open source programs with fast-growing communities. \pkg{RNetLogo} itself is open-source software published under the GNU GPL license.

\pkg{RNetLogo} consists of two parts: \proglang{R} code and \proglang{Java} code (Figure~\ref{fig:RNetLogoWorking}). The \proglang{R} code is responsible for offering the \proglang{R} functions, for connecting to \proglang{Java}, and for doing data transformations, while the \proglang{Java} code communicates with \proglang{NetLogo}.

To connect the \proglang{R} part of \pkg{RNetLogo} to the \proglang{Java} part the \pkg{rJava} package for \proglang{R} \citep{Urbanek2011} is used. The \pkg{rJava} package offers the ability to create objects, call methods and access class members of \proglang{Java} objects through the \pkg{Java Native Interface} (JNI) \citep{Oracle2013} from \proglang{C}. The \proglang{Java} part of the \pkg{RNetLogo} package connects to the \pkg{Java Controlling API} of \proglang{NetLogo}. This API allows controlling \proglang{NetLogo} from \proglang{Java} (and \proglang{Scala}) code \citep[for details, see][]{ControllingAPI2013}. 

When \proglang{NetLogo} code is given to an \pkg{RNetLogo} function, i.e. to the \proglang{R} part of \pkg{RNetLogo}, it is submitted through \pkg{rJava} to the \proglang{Java} part of \pkg{RNetLogo}, and from there to \proglang{NetLogo}'s \pkg{Controlling API} and thence to \proglang{NetLogo}. In case of reporters, i.e. primitives with return values, the return value is collected by the \proglang{Java} part of \pkg{RNetLogo}, transformed from \proglang{Java} to \proglang{R} by \pkg{rJava} and sent through the \proglang{R} part of \pkg{RNetLogo} to \proglang{R}.

\begin{figure}
  \centering
    \includegraphics{RNetLogoWorking}
  \caption{\pkg{RNetLogo} consists of two parts: an \proglang{R} and a \proglang{Java} part. The \proglang{R} part adds the \pkg{RNetLogo} functions to \proglang{R} and uses \pkg{rJava} to connect the \proglang{Java} part. The \proglang{Java} part connects to \proglang{NetLogo} via the \pkg{Controlling API} of \proglang{NetLogo}.}
  \label{fig:RNetLogoWorking}
\end{figure}

Currently \pkg{RNetLogo} provides 17 functions (Table~\ref{tab:RNetLogoFunctions}).

The functions that consume \proglang{NetLogo} code, like \code{NLCommand} or \code{NLReport}, expect it as a string. Some other functions, e.g. \code{NLGetAgentSet}, construct such strings internally from the different function arguments in the \proglang{R} part of \pkg{RNetLogo}. This string is then sent to the \proglang{Java} part of \pkg{RNetLogo} and from there it is evaluated through \proglang{NetLogo}'s \pkg{Controlling API}. 

When the submitted \proglang{NetLogo} code is not valid \proglang{NetLogo} throws an exception of type \code{Logo\-Exception} or \code{CompilerException} containing the corresponding error message. This exception is further thrown by the \proglang{Java} part of \pkg{RNetLogo}, handled by \pkg{rJava}, and requested finally by the \proglang{R} part of \pkg{RNetLogo} and printed to \proglang{R}'s command line. Runtime errors in \proglang{NetLogo}, like \code{java.lang.OutOfMemoryError}, are reported in the same manner. A message in \proglang{R}'s command line is printed. But errors where the JVM crashes can cause crashes in \pkg{rJava}, which can affect the \proglang{R} session as well.

Some functions of \pkg{RNetLogo}, like \code{NLDoCommand} or \code{NLDoReportWhile}, require further control flow handling, i.e. loops and condition checkings, which are done by the \proglang{Java} part of \pkg{RNetLogo}. 
The methods \code{command} and \code{report} of class \code{org.nlogo.workspace.Controllable}  of \proglang{NetLogo}'s \pkg{Controlling API} are used as interfaces to \proglang{NetLogo}. All other things are done by the \proglang{R} and the \proglang{Java} part of \pkg{RNetLogo}. 

\begin{landscape}
  \centering
	\captionsetup[longtable]{width=22cm}
		\begin{longtable}{|p{4cm}|p{8cm}|p{5cm}|p{4cm}|}
			\caption{Functions provided by \pkg{RNetLogo}. All functions take an additional (optional) argument \code{nl.obj} which is not listed in the table. It is a string identifying a \proglang{NetLogo} instance created with \code{NLStart}. Where functions take wildcard arguments (...) a short description is given in squared brackets. Optional arguments are marked with an asterisk. Details to the functions can be found in the manual pages of \pkg{RNetLogo}.			
			} 
			\label{tab:RNetLogoFunctions} 							
			\\
			\hline
			Function & Scope & Arguments & Return value \\ \hline \hline
			\code{NLStart} & Creates an instance of \proglang{NetLogo}. 
				&  
				\code{nl.path} \newline
				\code{gui}\textsuperscript{*} \newline
				\code{nl.version}\textsuperscript{*} \newline
				\code{is3d}\textsuperscript{*}
				& - 
			\\
			\code{NLLoadModel} & Loads a model into the \proglang{NetLogo} instance. 
				&  
				\code{model.path}
				& 
				- 			
			\\
			\code{NLQuit} & Quits a \proglang{NetLogo} instance. 
				& 
				\code{all}\textsuperscript{*}
				& 
				-
			\\
			\code{NLCommand} & Executes a command in the referenced \proglang{NetLogo} instance. 
				&
				\code{...} [strings containing \proglang{Net\-Logo} commands]
				& 
				-
			\\
			\code{NLDoCommand} & Repeats execution of a command in the referenced \proglang{NetLogo} instance a defined number of times. 
				&  
				\code{iterations} \newline
				\code{...} [strings containing \proglang{Net\-Logo} commands]
				&
				-
			\\
			\code{NLDoCommandWhile} & Repeats a command in the referenced \proglang{NetLogo} instance while a \proglang{NetLogo} reporter returns \code{TRUE}. 
				&
				\code{condition} \newline
				\code{...} [strings containing \proglang{Net\-Logo} commands] \newline
				\code{max.minutes}\textsuperscript{*}
				&
				-
			\\
			\code{NLReport} & Reports a value or list of values. 
				& 
				\code{reporter}
				&
				result of the reporter
			\\
			\code{NLDoReport} & Repeats a command and a reporter in the referenced \proglang{NetLogo} instance a defined number of times. 
				&  
				\code{iterations} \newline
				\code{command} \newline
				\code{reporter} \newline
				\code{as.data.frame}\textsuperscript{*} \newline
				\code{df.col.names}\textsuperscript{*}
				& 
				concatenated result of the repeated reporter calls
			\\
			\code{NLDoReportWhile} & Repeats execution of a command and a reporter in the referenced \proglang{NetLogo} instance while a conditional reporter returns \code{TRUE}. 
				&
				\code{condition} \newline
				\code{command} \newline
				\code{reporter} \newline
				\code{as.data.frame}\textsuperscript{*} \newline
				\code{df.col.names}\textsuperscript{*} \newline
				\code{max.minutes}\textsuperscript{*}
				& 
				concatenated result of the repeated reporter calls
			\\
			\code{NLGetAgentSet} & Reports variable values of one or more agents as a data frame (optionally as a list or vector). 
				&  
				\code{agent.var} \newline
				\code{agentset} \newline
				\code{as.data.frame}\textsuperscript{*} \newline
				\code{agents.by.row}\textsuperscript{*} \newline
				\code{as.vector}\textsuperscript{*}
				& 
				values of all requested agent variables of all requested agents
			\\
			\code{NLGetPatches} & Reports the values of patch variables as a data frame (optionally as a list, matrix or simple vector). 
				&
				\code{patch.var} \newline
				\code{patchset} \newline
				\code{as.matrix}\textsuperscript{*} \newline
				\code{as.data.frame}\textsuperscript{*} \newline
				\code{patches.by.row}\textsuperscript{*} \newline
				\code{as.vector}\textsuperscript{*}				
				& 
				values of all requested patch variables of all requested patches
			\\
			\code{NLGetGraph} & Captures a network of links.
				&
				\code{link.agentset}\textsuperscript{*} 				
				& 
				\pkg{igraph} graph object of link agents
			\\
			\code{NLSetAgentSet} & Sets a variable of one or more agents to values in a data frame or vector. 
				&
				\code{agentset} \newline
				\code{input} \newline
				\code{var.name} 
				& 
				-
			\\
			\code{NLSetPatches} & Sets a variable of all patches in the \proglang{NetLogo} world to the values in a matrix. 
				&  
				\code{patch.var} \newline
				\code{in.matrix}
				& 
				-
			\\
			\code{NLSetPatchSet} & Sets the variable value of one or more patches to values in a data frame.
				&  
				\code{input} \newline
				\code{patch.var}
				& 
				-
			\\
			\code{NLDfToList} & Transforms a data frame into a \proglang{NetLogo} list or multiple \proglang{NetLogo} lists (one for each column of the data frame). 
				&
				\code{in.data.frame}
				&
				-
			\\
			\code{NLSourceFromString} & Appends a string to the \proglang{NetLogo} model's code.
				&
				\code{...} [strings containing model source code] \newline
				\code{append.model}\textsuperscript{*} 
				& 
				-
			\\
			\hline
  \end{longtable}	
\end{landscape} 

\subsection[What else?]{What else?}
\label{sec:whatElse}

If only the integration of \proglang{R} calculations into \proglang{NetLogo} (the other way 
around) is of interest, a look at the \pkg{R-Extension} to \proglang{NetLogo} at \url{http://r-ext.sourceforge.net/}  \citep[see also][]{Thiele2010} can be useful.

If we want to use the \pkg{R-Extension} within a \proglang{NetLogo} model controlled by \pkg{RNetLogo}, we should use the \pkg{RServe-Extension} instead (available at \url{http://rserve-ext.sourceforge.net}), because loading the \pkg{R-Extension} will crash as it is not possible to load the \pkg{JRI-library} when \pkg{rJava} is active. 

\section[Using RNetLogo - Hands on]{Using \pkg{RNetLogo} - Hands on}
\label{sec:usingRnetlogo}

\subsection[Installation]{Installation}
\label{sec:installation}

To install and use \pkg{RNetLogo} we must have \proglang{R} 
(\url{http://cran.r-project.org/}) and \proglang{Net\-Logo} (\url{http://ccl.northwestern.edu/netlogo/download.shtml}) 
installed. The \pkg{RNetLogo} package is available from CRAN (\url{http://cran.r-project.org/web/packages/RNetLogo/}) and is installed like any other \proglang{R} package; 
see chapter 6 of \proglang{R}'s installation and administration manual \citep{Rcore2013c} 
for information on how to install a package. However, \pkg{RNetLogo} requires the 
\pkg{rJava} package \citep{Urbanek2011}, available from CRAN. It can happen that we have 
to reconfigure \proglang{Java}/\proglang{R} after installing \pkg{rJava} on Unix machines. This topic has been 
discussed several times; see, for example, \citet{RWiki2006}. 
The following subsections provide an introduction to the usage of \pkg{RNetLogo}, however, there are some pitfalls described in section~\ref{sec:pitfalls} one should be aware before starting own projects.

\subsection[Loading NetLogo]{Loading \proglang{NetLogo}}
\label{sec:packageLoading}

To use the \pkg{RNetLogo} package the first time in the current \proglang{R} 
session we have to load the package, like any other packages, with
<<label=sec_LoadingNetLogo_package-loading>>=
library("RNetLogo")
@ 

When loading \pkg{RNetLogo} it will automatically try to load \pkg{rJava}. If this runs 
without any error we are ready to start \proglang{NetLogo} (if not, see section~\ref{sec:installation}). 
To do so, we have to know where \proglang{NetLogo} is installed. What we need is the path 
to the folder that contains the \verb@NetLogo.jar@ file. On Windows machines this 
could be \code{C:/Program Files/NetLogo 5.0.4/}.

Now, we have to decide whether we want to run \proglang{NetLogo} in the background 
without seeing the Graphical User Interface (GUI) and control \proglang{NetLogo} completely 
from \proglang{R} or if we want to see and use the \proglang{NetLogo} GUI. In the latter case, we can 
use \proglang{NetLogo} as it was started independently, i.e., can load models, change the 
source code, click on buttons, see the \proglang{NetLogo} View, inspect agents, and so on, 
but also have control over \proglang{NetLogo} from \proglang{R}. The disadvantage of starting 
\proglang{NetLogo} with GUI is that we cannot run multiple instances of \proglang{NetLogo} in 
one \proglang{R} session. This is only possible in the so called headless mode, i.e., running 
\proglang{NetLogo} without GUI (see section~\ref{sec:headless} for details). 
Linux and Mac users should read the details section of the \code{NLStart} manual page (by typing \code{help(NLStart)}). 

Since the \proglang{NetLogo} Controlling API changes with the \proglang{NetLogo} version, 
we have to use an extra parameter \code{nl.version} to start \pkg{RNetLogo} for \proglang{NetLogo} 
version 4 (\code{nl.version=4} for \proglang{NetLogo} 4.1.x, \code{nl.version=40} for \proglang{NetLogo} 4.0.x). 
The default value of \code{nl.version} is 5, which means that we don't have
to submit this parameter when using \proglang{NetLogo} 5.0.x. Since \proglang{NetLogo} 5.0.x operates much faster on lists than older versions it is highly recommended to use it here (see also the \pkg{RNetLogo} package vignette \href{http://cran.r-project.org/web/packages/RNetLogo/vignettes/performanceNotes.pdf}{Performance Notes and Tests}).

To keep it simple and comprehensible we start \proglang{NetLogo} with GUI by typing:
<<label=sec_LoadingNetLogo_start-NetLogo-GUI, eval=False>>=
nl.path <- "C:/Program Files/NetLogo 5.0.4"
NLStart(nl.path)
@

<<label=sec_LoadingNetLogo_start-NetLogo-Headless_hidden, echo=False, results=hide>>=
# for Sweave production run NetLogo headless (faster)
nl.path <- "C:/Program Files/NetLogo 5.0.4"
NLStart(nl.path, gui = FALSE)
@

If everything goes right, a \proglang{NetLogo} Window will be opened. Please note that \proglang{R} 
does not use single backslashes in paths. We should use either forward slashes or 
doubled backslashes. We can use the \proglang{NetLogo} window as if it had been started independently, with the exception that we cannot close the window 
by clicking. On Windows, \proglang{NetLogo} appears in the same program group at the 
taskbar as \proglang{R}. 
If possible, arrange the \proglang{R} and \proglang{NetLogo} 
windows so that we have them side by side (Figure~\ref{fig:NLandRSideBySide}), and can see what is happening in \proglang{NetLogo} 
when we submit the following examples.

\begin{figure}
  \centering
    \includegraphics{NLandR1}
  \caption{\proglang{NetLogo} (on the right) started and controlled from \proglang{R} (on the left).}
  \label{fig:NLandRSideBySide}
\end{figure}

\subsection[Loading a model]{Loading a model}
\label{sec:modelLoading}

We can now open a \proglang{NetLogo} model by just clicking on "File -> Open..." 
or choosing one of the sample models by clicking on "File -> Models Library". 
But to learn to control \proglang{NetLogo} from \proglang{R} as when starting 
\proglang{NetLogo} in headless mode, we type in \proglang{R}:

<<label=sec_LoadingModel_load-model1>>=
model.path <- "models/Sample Models/Earth Science/Fire.nlogo"
NLLoadModel(paste(nl.path, model.path, sep = "/"))
@

The Forest Fire model \citep{Wilensky1997b} should be loaded. This model simulates 
a fire spreading through a forest. The expansion of the fire depends on the density of the forest. 
The forest is defined as a tree density value of the patches, while the fire is represented by turtles.
If we want, we can now change the initial tree density by using the slider on the Interface Tab and run the
simulation by clicking on the setup button first and then on the go button.
In the next section, we will do the same by controlling \proglang{NetLogo} from \proglang{R}.

\subsection[Principles of controlling a model]{Principles of controlling a model}
\label{sec:controlling}

In a first step, we will change the density value, i.e., the position of the density 
slider, by submitting the following statement in \proglang{R}:

<<label=sec_ControllingPrinciples_set-density>>=
NLCommand("set density 77")
@

The slider goes immediately to the position of 77 percent. We can now 
execute the \code{setup} procedure to initialize the simulation. We just submit in 
\proglang{R}:

<<label=sec_ControllingPrinciples_set-seed_hidden, echo=FALSE, results=hide>>=
NLCommand("random-seed 123456789")
@

<<label=sec_ControllingPrinciples_NLCommand1>>=
NLCommand("setup")
@

And again, the command is executed immediately. The tick counter is reset 
to 0, the View is green and first fire turtles are found on the left side of the View.
Please notice that the \code{NLCommand} function does not press the \code{setup} button, but 
calls the \code{setup} procedure. In the Forest Fire example it makes no difference as 
the setup button also just calls the \code{setup} procedure, but it is possible to add 
more code to a button than just calling a procedure. But we can copy and 
paste such code into the \code{NLCommand} function as well.

We now want to run one tick by executing the \code{go} procedure. This is nothing new; we just submit in 
\proglang{R}:

<<label=sec_ControllingPrinciples_NLCommand2>>=
NLCommand("go")
@

We see that the tick counter was incremented by one and the red line of the 
fire turtles on the left of the View extended to the next patch.

As we have seen, the \code{NLCommand} function can be used to execute any command 
which could be typed into \proglang{NetLogo}'s Command Center. We can, for example, 
print a message into \proglang{NetLogo}'s Command Center with the following statement:

<<label=sec_ControllingPrinciples_NLCommand3>>=
NLCommand("print \"Hello NetLogo, I called you from R.\"")
@

The backslashes in front of the  quotation marks are used to 'mask' the quotation 
marks; otherwise \proglang{R} would think that the command string ends after the 
\code{print} and would be confused. Furthermore, it is possible to submit more than 
one command at once and in combination with \proglang{R} variables. We can change 
the density slider and execute \code{setup} and \code{go} with one \code{NLCommand} call like this:

<<label=sec_ControllingPrinciples_NLCommand4>>=
density.in.r <- 88
NLCommand("set density ", density.in.r, "setup", "go")
@

In most cases, we do not want to execute a go procedure only a single time but for, say, 
ten times (ticks). With the \pkg{RNetLogo} package we can do this with:

<<label=sec_ControllingPrinciples_NLDoCommand>>=
NLDoCommand(10, "go")
@

Now we have run the simulation eleven ticks and maybe want to 
have this information in \proglang{R}. Therefore, we execute:

<<label=sec_ControllingPrinciples_NLReport1>>=
NLReport("ticks")
@

As you might expect, we can save this value in an \proglang{R} variable by typing:

<<label=sec_ControllingPrinciples_NLReport2>>=
ticks <- NLReport("ticks")
print(ticks)
@

This was already the basic functionality of the \pkg{RNetLogo} 
package. In the following subsection we mostly modify and/or
extend this basic functionality.

\proglang{NetLogo} users should note that there is no "forever button". To run a simulation for several ticks we can use one of the loop functions (\code{NLDoCommand}, \code{NLDoCommandWhile}, \code{NLDoReport}, \code{NLDoReportWhile}) or write a custom procedure in \proglang{NetLogo} that runs the \code{go} procedure the desired number of times when called once by \proglang{R}. 

To quit a \proglang{NetLogo} session, i.e., to close a \proglang{NetLogo} instance, we have to use 
the \code{NLQuit} function. If we used the standard GUI mode without assigning the \proglang{NetLogo} instance to an \proglang{R} variable, we can write:

<<label=sec_ControllingPrinciples_NLQuit, eval=FALSE>>=
NLQuit()
@

Otherwise, we have to specify which \proglang{NetLogo} instance we want to close 
by giving the \proglang{R} variable storing it. Please note that there is currently no way to close the GUI mode 
completely. That is why we cannot run \code{NLStart} again in the same \proglang{R} session when \proglang{NetLogo} was started with its GUI.
  
\subsection[Advanced controlling functions]{Advanced controlling functions}
\label{sec:advancedControlling}

In subsection~\ref{sec:controlling}, we used the \code{NLDoCommand} function to run the 
simulation for ten ticks. Here, we will run the model for ten ticks as well, 
but we will collect the percentage of burned trees after every tick 
automatically:

<<label=sec_AdvancedControlling_set-seed_hidden, echo=FALSE, results=hide>>=
NLCommand("random-seed 123456789")
@

<<label=sec_AdvancedControlling_NLDoReport>>=
NLCommand("setup")
burned <- NLDoReport(10, "go", "(burned-trees / initial-trees) * 100")
print(unlist(burned))
@

This code ran the simulation for ten ticks and wrote the result of the given 
reporter (the result of the calculation of the percentage of burned trees) after 
every tick into the \proglang{R} list \code{burned}.

If we want to run the simulation until no trees are left and know the percentage 
of burned trees in every tick, we can execute:

<<label=sec_AdvancedControlling_NLDoReportWhile, fig=FALSE, include=FALSE>>=
NLCommand("setup")
burned <- NLDoReportWhile("any? turtles", 
                          "go", 
                          c("ticks", 
                            "(burned-trees / initial-trees) * 100"), 
                          as.data.frame = TRUE, 
                          df.col.names = c("tick", "percent burned"))
plot(burned, type = "s")
@

<<label=sec_AdvancedControlling_plot-burned_hidden, fig=TRUE, include=False, echo=FALSE>>=
par.default <- par(no.readonly = TRUE)
par(mar = c(3.5, 3.1, 0.5, 0.6))
par(xpd = T)
par(cex = 1.5)
plot(burned, type = "s", xlab = "", ylab = "", ylim = c(0, 100), xlim = c(0, 300))
title(xlab = "tick", mgp = c(2.2, 0, 0))
title(ylab = "percent burned", mgp = c(2.2, 0, 0)) 
par(par.default)
@

\begin{figure}
  \centering
  \includegraphics[width=0.5\textwidth]{./images/-sec_AdvancedControlling_plot-burned_hidden} \hfill
  \caption{The percentage of burned trees over time as the result of 
          \code{NLDoReportWhile}, which runs as long as there are turtles 
          (\code{any?\ turtles}).}
  \label{fig:NLDoReportWhile1}
\end{figure}

The first argument of the function takes a \proglang{NetLogo} reporter. Here, the \code{go} procedure will be executed while 
there are turtles in the simulation, i.e., \code{any?\ turtles} reports \code{true}. Moreover, we have
used not just one reporter (third argument) but a vector of two reporters; one returning the current simulation time (\code{tick}) and a second with the percentage of burned trees. 
Furthermore, we have defined that our output should be saved as a data frame 
instead of a list and we have given the names of the columns of the data frame 
by using a vector of strings in correspondence to the reporters. At 
the end, the \proglang{R} variable \code{burned} is of type \code{data.frame} and contains two columns; one with the \code{tick} number and a second with the corresponding percentage 
of burned trees. By using the standard plot function, we graph the percentage of burned trees over time (Figure~\ref{fig:NLDoReportWhile1}).

To demonstrate the \code{NLGetAgentSet} function, we use a different 
model. Therefore, we load the Tumor model from \proglang{NetLogo}'s Model Library, 
set it up and run it for 20 ticks, as follows:

<<label=sec_AdvancedControlling_load-model2>>=
model.path <- "models/Sample Models/Biology/Tumor.nlogo"
NLLoadModel(paste(nl.path, model.path, sep = "/"))
NLCommand("setup")
NLDoCommand(20, "go")
@

After we have run 20 ticks, we load the x and y positions of all tumor cells 
(which are turtles) into a data frame and show them in a plot. But before we call the plot function, we will get 
the spatial extent of the \proglang{NetLogo} World to use in the plot window (Figure~\ref{fig:getAgentSet1}): 

<<label=sec_AdvancedControlling_NLGetAgentSet1, fig=FALSE, include=FALSE>>=
cells <- NLGetAgentSet(c("xcor", "ycor"), "turtles")
x.minmax <- NLReport("(list min-pxcor max-pxcor)")
y.minmax <- NLReport("(list min-pycor max-pycor)")
plot(cells, xlim = x.minmax, ylim = y.minmax, xlab = "x", ylab = "y")
@

\begin{figure}
  \centering
    \includegraphics{NLandR_GetAgentSet1}
  \caption{A visualization of turtle locations obtained via \code{NLGetAgentSet}. 
  Turtle locations are displayed in the original \proglang{NetLogo} simulation (right) and in 
  the \proglang{RGUI} (left).}
  \label{fig:getAgentSet1}
\end{figure}

In a second step, we get only the metastatic cells and plot them again 
(Figure~\ref{fig:getAgentSet2}):

<<label=sec_AdvancedControlling_NLGetAgentSet2, fig=FALSE, include=FALSE>>=
cells.metastatic <- NLGetAgentSet(c("xcor", "ycor"),
                                  "turtles with [metastatic? = True]")
plot(cells.metastatic, xlim = x.minmax, ylim = y.minmax, 
     xlab = "x", ylab = "y")
@

<<label=sec_AdvancedControlling_plot-metastatic_hidden, fig=TRUE, include=False, echo=FALSE>>=
par.default <- par(no.readonly = TRUE)
par(mar = c(3.5, 3.1, 0.5, 0.5))
par(xpd = T)
par(cex = 1.5)
plot(cells.metastatic, xlim = x.minmax, ylim = y.minmax, xlab = "", ylab = "")
title(xlab = "x", mgp = c(2.2, 0, 0))
title(ylab = "y", mgp = c(2.2, 0, 0)) 
par(par.default)
@

\begin{figure}
  \centering
  \includegraphics[width=0.5\textwidth]{./images/-sec_AdvancedControlling_plot-metastatic_hidden} \hfill
  \caption{Same as in Figure~\ref{fig:getAgentSet1} but with a subset of turtles that fulfill a condition (are metastatic cells).}
  \label{fig:getAgentSet2}
\end{figure}

We can use the \code{NLGetAgentSet} function to get patches and links as well. 
But there is a special function for patches, called \code{NLGetPatches}, which makes 
life easier by returning the patch values as a matrix. We test this function by using the Fur model about patterns on 
animals' skin self-organization and plot the result in a simple raster image (Figure~\ref{fig:getPatches1}).
We load the model, set it up and get the patches as a matrix
<<label=sec_AdvancedControlling_load-model2>>=
model.path <-"models/Sample Models/Biology/Fur.nlogo"
NLLoadModel(paste(nl.path, model.path, sep = "/"))
NLCommand("setup")
NLDoCommand(5, "go")
patches.matrix <- NLGetPatches("pcolor", "patches", as.matrix = TRUE)
@
Now, we reorganize the matrix to make it fit for the image function and define the image colors:
<<label=sec_AdvancedControlling_transform-matrix>>=
patches.matrix.rot <- t(patches.matrix)
patches.matrix.rot <- as.data.frame(patches.matrix.rot)
patches.matrix.rot <- rev(patches.matrix.rot)
patches.matrix.rot <- as.matrix(patches.matrix.rot)
col <- c("black", "white")
@

Afterwards, we get the x and y limits (of the World) to use them for the image and draw the matrix as an image:
<<label=sec_AdvancedControlling_get-world-dim, fig=FALSE, include=FALSE>>=
x.minmax <- NLReport("(list min-pxcor max-pxcor)")
y.minmax <- NLReport("(list min-pycor max-pycor)")
image(x.minmax[1]:x.minmax[2], y.minmax[1]:y.minmax[2], 
      patches.matrix.rot, col = col, xlab = "x", ylab = "y")
@

<<label=sec_AdvancedControlling_image-patches_hidden, fig=TRUE, include=False, echo=FALSE>>=
par.default <- par(no.readonly = TRUE)
par(mar = c(3.0, 3.0, 0.5, 0.5))
par(xpd = T)
par(cex = 1.5)
image(x.minmax[1]:x.minmax[2], y.minmax[1]:y.minmax[2], 
      patches.matrix.rot, col = col, xlab = "", ylab = "")
title(xlab = "x", mgp = c(2.2, 0, 0))
title(ylab = "y", mgp = c(2.2, 0, 0))
par(par.default)
@

\begin{figure}
  \centering
  \includegraphics[width=0.5\textwidth]{./images/-sec_AdvancedControlling_image-patches_hidden} \hfill
  \caption{A simple visualization of the result of \code{NLGetPatches} as an image.}
  \label{fig:getPatches1}
\end{figure}

The code produced a simple raster image from the patches. It is also possible 
to create a spatial object from the result of \code{NLGetPatches} as we see in the next 
example (packages \pkg{gstat} \citep{Pebesma2011} and \pkg{sp} \citep{Pebesma2011b} are used). 

<<label=sec_AdvancedControlling_redefine-spplot_hidden, echo=FALSE, results=hide>>=
# spplot function and Sweave do not work together, therefore define a wrapper as described here:
# https://stat.ethz.ch/pipermail/r-sig-geo/2009-September/006383.html
library("sp")
spplot.orig = spplot
spplot = function(...){print(spplot.orig(...))}
@

We start by loading the required packages and  get the patches or, more precisely, the colors and coordinates of the patches:
<<label=sec_AdvancedControlling_NLGetPatches2>>=
library("sp", "gstat")
patches <- NLGetPatches(c("pxcor", "pycor", "pcolor"), "patches")
@

Next, we convert the patches \code{data.frame} to a \code{Spatial\-Points\-Data\-Frame} and use this \code{Spatial\-Points\-Data\-Frame} to create a \code{Spatial\-Pixels\-Data\-Frame}:
<<label=sec_AdvancedControlling_make-spatialPointsDataFrame>>=
coordinates(patches) <- ~ pxcor + pycor
gridded(patches) <- TRUE
@

Now, we convert \code{pcolor} to a factor, define the colors for the plot and create it (not shown here, similar to Figure~\ref{fig:getPatches1}):
<<label=sec_AdvancedControlling_make-factor, fig=FALSE, include=FALSE>>=
patches$pcolor <- factor(patches$pcolor)
col <- c("black", "white")
spplot(patches, "pcolor", col.regions = col, xlab = "x", ylab = "y")
@

We see that it is possible to get the whole \proglang{NetLogo} View. As we can see in 
its manual page, we can save the result of \code{NLGetPatches} into a list, 
matrix or, like here, into a data frame. Furthermore, we can reduce the patches 
to a subset, e.g., all patches that fulfill a condition, as we have done in the 
\code{NLGetAgentSet} example.
 
There are two other functions that operate the other way around. With 
\code{NLSetPatches} and \code{NLSetPatchSet} we can push an \proglang{R} matrix/data frame into the \proglang{NetLogo} patches. \code{NLSetPatches} function 
works only if we fill all patches, i.e., if we use a matrix which has the dimension of 
the \proglang{NetLogo} World. For filling just a subset of patches we can use the \code{NLSetPatchSet} function. 

The following example shows the usage of the \code{NLSetPatches} function (attention: this is relatively slow due to the drawing procedure). 

We reuse the \code{patches.matrix} variable from \code{NLGetPatches}, change the values from 0 (black) to 15 (red) and use this new matrix as input for the \proglang{NetLogo} patch variable \code{pcolor} (Figure~\ref{fig:setPatches1}): 
<<label=sec_AdvancedControlling_change-matrix>>=
my.matrix <- replace(patches.matrix, 
                     patches.matrix == 0, 
                     15)
NLSetPatches("pcolor", my.matrix)
@

\begin{figure}
  \centering
    \includegraphics{NLandR_SetPatches1}
  \caption{A screenshot while \code{NLSetPatches} is executing. The color of the \proglang{NetLogo} 
  patches on the right hand side is changed gradually from black to red.}
  \label{fig:setPatches1}
\end{figure}

Another function, \code{NLGetGraph}, makes it possible to get a \proglang{NetLogo} network built by 
\proglang{NetLogo} links into an \pkg{igraph} network. This function requires the \proglang{R} 
package \pkg{igraph} \citep{Csardi2006}. As an example, we can use the Small World model 
from \proglang{NetLogo}'s Models Library. We build the \proglang{NetLogo} link network and 
transform it into an \pkg{igraph} network and finally plot it.

<<label=sec_AdvancedControlling_psoptions_hidden, echo=FALSE, results=hide>>=
ps.options(fonts = c("serif", "sans", "mono"))
@

We start by loading as well as setting up the model and get the graph from \proglang{NetLogo}:
<<label=sec_AdvancedControlling_load-model3>>=
model.path <- "models/Sample Models/Networks/Small Worlds.nlogo"
NLLoadModel(paste(nl.path, model.path, sep = "/"))
NLCommand("setup", "rewire-all")
my.network <- NLGetGraph()
@

Now, the directed network graph plot (Figure~\ref{fig:figNLGetGraph1}) can be obtained with:
<<label=sec_AdvancedControlling_plot-network, fig=FALSE, include=FALSE>>=
plot(my.network, layout = layout.circle, 
     vertex.label = V(my.network)$name,
     vertex.label.cex = 0.7,
     asp = FALSE)
@

<<label=sec_AdvancedControlling_plot-network_hidden, fig=TRUE, include=False, echo=FALSE>>=
par.default <- par(no.readonly = TRUE)
par(mar = c(0.5, 0.5, 0.5, 0.5))
par(xpd = T)
par(cex = 1.5)
plot(my.network, layout = layout.circle, 
     vertex.label = V(my.network)$name,
     vertex.label.cex = 0.7,
     asp = FALSE)
par(par.default)
@
  
\begin{figure}
  \centering
  \includegraphics[width=0.5\textwidth]{./images/-sec_AdvancedControlling_plot-network_hidden} \hfill
  \caption{A graph generated by \proglang{NetLogo} links, sent to \proglang{R} via \code{NLGetGraph}, and plotted using the \pkg{igraph} package.}
  \label{fig:figNLGetGraph1}
\end{figure}

There are two further functions, which are not presented here in detail. 
The first one is the \code{NLSourceFromString} function, which enables us to create 
or append model source code from strings in \proglang{R}. A usage example is given in the code sample folder (No. 16) of the \pkg{RNetLogo} package. Another helper function to send a data frame into 
\proglang{NetLogo} lists is \code{NLDfToList}. The column names of 
the data frame have to be equivalent to the names of the lists in the \proglang{NetLogo} 
model. The code sample folder (No. 9) includes a usage example.

\subsection[Headless mode/Multiple NetLogo instances]{Headless mode/Multiple \proglang{NetLogo} instances}
\label{sec:headless}

As mentioned above, it is possible to start \proglang{NetLogo} in background (headless 
mode) without a GUI. For this, we have to execute 
the \code{NLStart} function with a second argument. This will fail if we do not open 
a new \proglang{R} session (after using \pkg{RNetLogo} in GUI mode) because, as mentioned above, we cannot start several \proglang{NetLogo} sessions if we have already started one in GUI mode.

<<label=sec_Headless_startHeadless0_hidden, eval=False, echo=False>>=
NLStart(nl.path, gui = FALSE)
@

The \code{NLStart} function will save the \proglang{NetLogo} object reference in an internal variable in the local environment \code{.rnetlogo}. If 
we want to work with more than one \proglang{NetLogo} model/instance at once, we can 
specify an identifier (as a string) for the \proglang{NetLogo} instance 
in the third argument of \code{NLStart}.

We start with the creation of three \proglang{NetLogo} instances
(maybe beside the one with the default identifier which is \code{_nl.intern_}):
<<label=sec_Headless_startHeadless1>>=
my.netlogo1 <- "my.netlogo1"
NLStart(nl.path, 
        gui = FALSE, 
        nl.obj = my.netlogo1)

my.netlogo2 <- "my.netlogo2"
NLStart(nl.path, 
        gui = FALSE, 
        nl.obj = my.netlogo2)

my.netlogo3 <- "my.netlogo3"
NLStart(nl.path, 
        gui = FALSE, 
        nl.obj = my.netlogo3)
@

All functions presented until now take as last (optional) argument (\code{nl.obj}) a string which identifies a specific \proglang{NetLogo} instance created with \code{NLStart}. Therefore, we can specify which instance we want to use. When working in headless mode, the first thing to do is always to load a 
model. Executing a command or reporter without loading a model in headless 
mode will result in an error. Therefore, we load a model into all instances: 

<<label=sec_Headless_load-model1>>=
model.path <- "models/Sample Models/Earth Science/Fire.nlogo"
NLLoadModel(paste(nl.path, model.path, sep = "/"), 
            nl.obj = my.netlogo1)

NLLoadModel(paste(nl.path, model.path, sep = "/"), 
            nl.obj = my.netlogo2)

NLLoadModel(paste(nl.path, model.path, sep = "/"), 
            nl.obj = my.netlogo3)
@

Now, we will set up and run the models over different simulation times. 

We run the first instance (\code{my.netlogo1}) for 25 ticks:
<<label=sec_Headless_NLCommand1>>=
NLCommand("setup", nl.obj = my.netlogo1)
NLDoCommand(25, "go", nl.obj = my.netlogo1)
@

Then, we run the second instance (\code{my.netlogo2}) for 15 ticks:
<<label=sec_Headless_NLCommand2>>=
NLCommand("setup", nl.obj = my.netlogo2)
NLDoCommand(15, "go", nl.obj = my.netlogo2)
@

and we simulate 5 ticks with the third instance:
<<label=sec_Headless_NLCommand3>>=
NLCommand("setup", nl.obj = my.netlogo3)
NLDoCommand(5, "go", nl.obj = my.netlogo3)
@

To check if the above worked well, we compare the number of burned trees in the different instances, which should be different:
<<label=sec_Headless_NLReport>>=
NLReport("burned-trees", nl.obj = my.netlogo1)
NLReport("burned-trees", nl.obj = my.netlogo2) 
NLReport("burned-trees", nl.obj = my.netlogo3)
@

At the end, we quit the \proglang{NetLogo} sessions (the standard session with internal identifier \code{_nl.intern_} as well, if open):
<<label=sec_Headless_NLQuit, eval=FALSE>>=
NLQuit(nl.obj = my.netlogo3)
NLQuit(nl.obj = my.netlogo2)
NLQuit(nl.obj = my.netlogo1)
NLQuit() 
@

\section[Application examples]{Application examples}
\label{sec:application}

The following examples are (partly) inspired by the examples presented for \proglang{NetLogo}'s \pkg{Mathematica Link} \citep[see][]{Bakshy2007}. These are all one-directional examples (from \proglang{NetLogo} to \proglang{R}), but the package opens the possibility of letting \proglang{NetLogo} and \proglang{R} interact and send back results from \proglang{R} (e.g., statistical analysis) to \proglang{NetLogo} and let the model react to them. Even manipulation of the model source by using the \code{NLSourceFromString} function is possible. This opens the possibility to generate \proglang{NetLogo} code from \proglang{R} dynamically.

\subsection[Exploratory analysis]{Exploratory analysis}
\label{sec:exploratoryAnalysis}

A simple parameter sensitivity experiment illustrates exploratory analysis with \pkg{RNetLogo}, even though \proglang{NetLogo} has a very powerful built-in tool, \pkg{BehaviorSpace} \citep{Wilensky2012}, for this simple kind of experiment. Here, we will use the Forest Fire model \citep{Wilensky1997b} from \proglang{NetLogo}'s Models Library and explore the effect of the density of trees in the forest on the percentage of burned trees as described in \citet{Bakshy2007}.

We start, as always, by loading and initializing the package (if not already done) and model:
<<label=sec_ApplExample_ExplAnalysis_init, eval=FALSE>>=
library("RNetLogo")
nl.path <- "C:/Program Files/NetLogo 5.0.4"
NLStart(nl.path, gui = FALSE)
model.path <- "models/Sample Models/Earth Science/Fire.nlogo"
NLLoadModel(paste(nl.path, model.path, sep = "/"))
@
<<label=sec_ApplExample_loadModel_hidden, echo=FALSE, results=hide>>=
model.path <- "models/Sample Models/Earth Science/Fire.nlogo"
NLLoadModel(paste(nl.path, model.path, sep = "/"))
@

Next, we define a function which sets the density of trees, executes the simulation until no turtles are left, and reports back the percentage of burned trees:
<<label=sec_ApplExample_ExplAnalysis_define-sim-function>>=
sim <- function(density) {
    NLCommand("set density ", density, "setup")
    NLDoCommandWhile("any? turtles", "go");
    ret <- NLReport("(burned-trees / initial-trees) * 100")
    return(ret)  
}
@

We run the simulation for density values between 1 and 100 with a step size of 1, to identify the phase transition (Figure~\ref{fig:explor_plot_first}): 
<<label=sec_ApplExample_ExplAnalysis_plot-first, fig=FALSE, include=FALSE>>=
d <- seq(1, 100, 1)
pb <- sapply(d, function(dens) {sim(dens)})
plot(d, pb, xlab = "density", ylab = "percent burned")
@

<<label=sec_ApplExample_ExplAnalysis_plot-first_hidden, fig=TRUE, include=False, echo=FALSE>>=
par.default <- par(no.readonly = TRUE)
par(mar = c(3.5, 3.5, 0.5, 0.5))
par(xpd = T)
par(cex = 1.5)
plot(d, pb, xlab = "", ylab = "", ylim = c(0, 100))
title(xlab = "density", mgp = c(2.2, 0, 0))
title(ylab = "percent burned", mgp = c(2.2, 0, 0)) 
par(par.default)
@

\begin{figure}
  \centering
  \includegraphics[width=0.5\textwidth]{./images/-sec_ApplExample_ExplAnalysis_plot-first_hidden} \hfill
  \caption{Results of the Forest Fire model varying the density of trees. The y-axis is the percentage of burned trees after no burning patches (i.e., no turtles) were left in the simulation.}
  \label{fig:explor_plot_first}
\end{figure}

As we know the region of phase transition (between a density of 45 and 70 percent), we can explore this region more precisely. As the Forest Fire model uses random numbers, it is interesting to find out how much stochastic variation occurs in this region. Therefore, we define a function to repeat the simulations with one density several times:

<<label=sec_ApplExample_ExplAnalysis_define-repetition-function>>=
rep.sim <- function(density, rep) {
  return(
    lapply(density, function(dens) {    
      replicate(rep, sim(dens))
    })
  )  
}
@

To get a rough overview we use this new function for densities between 45 and 70 percent with a step size of 5, and 10 replications each (Figure~\ref{fig:explor_plot_second}):
<<label=sec_ApplExample_ExplAnalysis_plot-second, fig=FALSE, include=FALSE>>=
d <- seq(45, 70, 5)
res <- rep.sim(d, 10)
boxplot(res, names = d, xlab = "density", ylab = "percent burned")
@

<<label=sec_ApplExample_ExplAnalysis_plot-second_hidden, fig=TRUE, include=False, echo=FALSE>>=
par.default <- par(no.readonly = TRUE)
par(mar = c(3.5, 3.5, 0.5, 0.5))
par(xpd = T)
par(cex = 1.5)
boxplot(res, names = d, xlab = "", ylab = "", ylim = c(0, 100))
title(xlab = "density", mgp = c(2.2, 0, 0))
title(ylab = "percent burned", mgp = c(2.2, 0, 0)) 
par(par.default)
@  
  
\begin{figure}
  \centering
  \includegraphics[width=0.5\textwidth]{./images/-sec_ApplExample_ExplAnalysis_plot-second_hidden} \hfill
  \caption{Boxplots of repeated simulations (10 replications) with the Forest Fire model with varying density (45-70 percent) of trees and the percentage of burned trees after no turtles were left in the simulation.}
  \label{fig:explor_plot_second}
\end{figure}

Now, we have seen that the variation of burned trees at densities below 55 and higher than 65 is low. As a result, we can skip these values and have a deeper look into the region of density values between 55 and 65. Therefore, we perform a simulation experiment for this value range with a smaller step size of 1 percent and a higher amount of replication of 20 per density value (Figure~\ref{fig:explor_plot_third}): 

<<label=sec_ApplExample_ExplAnalysis_plot-third, fig=FALSE, include=FALSE>>=
d <- seq(55, 65, 1)
res <- rep.sim(d, 20)
boxplot(res,names = d, xlab = "density", ylab = "percent burned")
@

<<label=sec_ApplExample_ExplAnalysis_plot-third_hidden, fig=TRUE, include=False, echo=FALSE>>=
par.default <- par(no.readonly = TRUE)
par(mar = c(3.5, 3.5, 0.5, 0.5))
par(xpd = T)
par(cex = 1.5)
boxplot(res,names = d, xlab = "", ylab = "", ylim = c(0, 100))
title(xlab = "density", mgp = c(2.2, 0, 0))
title(ylab = "percent burned", mgp= c(2.2, 0, 0)) 
par(par.default)
@  
 
\begin{figure}
  \centering
  \includegraphics[width=0.5\textwidth]{./images/-sec_ApplExample_ExplAnalysis_plot-third_hidden} \hfill
  \caption{Boxplots of repeated simulations (20 replications) with the Forest Fire model with varying density (55-65 percent) of trees and the percentage of burned trees after no turtles were left in the simulation.}
  \label{fig:explor_plot_third}
\end{figure}

\subsection[Database connection]{Database connection}
\label{sec:databaseConnection}

Since there are \proglang{R} packages available to connect all common database management systems (e.g., \pkg{RMySQL} \citep{James2012}, \pkg{RPostgreSQL} \citep{Conway2012}, \pkg{ROracle} \citep{Mukhin2012}, \pkg{RJDBC} \citep{Urbanek2011b}, \pkg{RSQLite} \citep{James2011} or \pkg{RODBC} \citep{Ripley2012}), the \pkg{RNetLogo} package opens the possibility to store the simulation results into a database. 

In the following example we use the \pkg{RSQLite} package, which provides a connection to SQLite databases \citep{Hipp2012}, because this is a very easy-to-use database in a single file. It does not need a separate database server and is, therefore, ideal for agent-based modeling studies, where no large database management systems (DBMS) are used. The database can store the results of different simulation experiments in different tables together with metadata in one file. This makes it very easy to share simulation results. There are small and easy-to-use GUI-programs available to browse and edit SQLite databases; see, for example, the SQLite Database Browser \citep{Piacentini2012}.

In a first step we have to set up the connections to \proglang{NetLogo} (if not already done) and load as well as initialize the example model:

<<label=sec_ApplExample_Database_init, eval=FALSE>>=
library("RNetLogo")
nl.path <- "C:/Program Files/NetLogo 5.0.4"
NLStart(nl.path, gui = FALSE)
model.path <- "models/Sample Models/Earth Science/Fire.nlogo"
NLLoadModel(paste(nl.path, model.path, sep = "/"))
NLCommand("setup")
@ 
<<label=sec_ApplExample_Database_loadModel_hidden, echo=FALSE, results=hide>>=
model.path <- "models/Sample Models/Earth Science/Fire.nlogo"
NLLoadModel(paste(nl.path, model.path, sep = "/"))
NLCommand("setup")
@ 

<<label=sec_ApplExample_Database_setup_hidden, echo=FALSE, results=hide>>=
NLCommand("setup")
@

Then, we load the required \pkg{RSQLite} package and database driver as well as create a connection to the database. If the database does not exist, this creates a file \code{test_netlogo.db}:
<<label=sec_ApplExample_Database_load-package, eval=FALSE>>=
library("RSQLite")
m <- dbDriver("SQLite")
database.path = "C:/test_netlogo.db"
con <- dbConnect(m, dbname = database.path)
@

<<label=sec_ApplExample_Database_set-db_hidden, echo=FALSE, results=hide>>=
library("RSQLite")
m <- dbDriver("SQLite")
database.path <- database.path.hidden
if (file.exists(database.path)) {
  file.remove(database.path)
}
con <- dbConnect(m, dbname = database.path)
@

Next, we run the model for ten ticks and save the results (ticks and burned-trees) in the table \code{Burned1} of the database:
<<label=sec_ApplExample_Database_write-table1, results=hide>>=
dbWriteTable(con, "Burned1", 
             NLDoReport(10, "go", c("ticks", "burned-trees"),
             as.data.frame = TRUE, df.col.names = c("tick", "burned")), 
             row.names = FALSE, append = FALSE)
@

Afterwards, we can send a first query: how many lines has the new table? 
<<label=sec_ApplExample_Database_query1>>=
dbGetQuery(con, "select count(*) from Burned1")[[1]]
@

In the second query, we select all rows from table \code{Burned10} where tick is greater than 5:
<<label=sec_ApplExample_Database_query2>>=
rs <- dbSendQuery(con, "select * from Burned1 where tick > 5")
@

Then, we ask for the result of the query and print it:
<<label=sec_ApplExample_Database_get-data1>>=
data <- fetch(rs, n = -1)
str(data)
@

Next, we delete/clear the query:
<<label=sec_ApplExample_Database_clear-query, results=hide>>=
dbClearResult(rs)
@

Afterwards, we append further results to the existing table:
<<label=sec_ApplExample_Database_write-table2, results=hide>>=
dbWriteTable(con, "Burned1", 
             NLDoReport(10, "go", c("ticks", "burned-trees"),
             as.data.frame = TRUE, df.col.names = c("tick", "burned")), 
             row.names = FALSE, append = TRUE)
@

and take a look into the table:
<<label=sec_ApplExample_Database_query3>>=
select.all <- dbGetQuery(con, "select * from Burned1")
str(select.all)
@

Now, we create a second table and save the results of ten repeated simulations of 20 ticks each:
<<label=sec_ApplExample_Database_write-table3>>=
for (x in 1:10)
{
  NLCommand("setup")
  dbWriteTable(con, "Burned2", 
               NLDoReport(20, "go", c("ticks", "burned-trees"),
               as.data.frame = TRUE, df.col.names = c("tick", "burned")), 
               row.names = FALSE, append = TRUE)
}
@

and calculate the mean number of burned trees (out of the 10 repetitions) for each tick, get the result of the query and show it:
<<label=sec_ApplExample_Database_query4>>=
rs <- dbSendQuery(con, "select avg(burned) as mean_burned 
                        from Burned2 group by tick")
data <- fetch(rs, n = -1)
str(data)
@

Finally, we delete/clear the query and close the connection to the database:
<<label=sec_ApplExample_Database_close, results=hide>>=
dbClearResult(rs)
dbDisconnect(con)
@
<<label=sec_ApplExample_Database_remove-db_hidden, echo=FALSE, results=hide>>=
# a hidden removal of the database
if (file.exists(database.path)) {
  file.remove(database.path)
}
@

Note that there is also an extension to connect databases directly to \proglang{NetLogo} (see \url{http://code.google.com/p/netlogo-sql/}). 

\subsection[Analytical comparison]{Analytical comparison}
\label{sec:analyticalComparison}

The example application of \citet{Bakshy2007} compares results of an agent-based model of gas particles to velocity distributions found in analytical treatments of ideal gases. To reproduce this, we use the Free Gas model \citep{Wilensky1997} of the GasLab model family from \proglang{NetLogo}'s Models Library. In this model, gas particles move and collide with each other without external constraints. \citet{Bakshy2007} compared this model's results to the classical Maxwell-Boltzmann distribution. 
\proglang{R} itself is not symbolic mathematical software but there are packages available which let us integrate such software. Here, we use the \pkg{Ryacas} package \citep{Goedman2010} which is an interface to the open-source \proglang{Yacas} Computer Algebra System \citep{Pinkus2007}. 

We start with the agent-based model simulation. Because this model is based on random numbers we run repeated simulations. 

We start with loading and initializing the \pkg{RNetLogo} package (if not already done) and the model:
<<label=sec_ApplExample_GasLab_init, eval=FALSE>>=
library("RNetLogo")
nl.path <- "C:/Program Files/NetLogo 5.0.4"
NLStart(nl.path, gui = FALSE)
model.path1 <- "models/Sample Models/Chemistry & Physics/GasLab"
model.path2 <- "GasLab Free Gas.nlogo"
NLLoadModel(paste(nl.path, model.path1, model.path2, sep = "/"))
NLCommand("set number-of-particles 500", "no-display", "setup")
@
<<label=sec_ApplExample_GasLab_loadModel_hidden, echo=FALSE, results=hide>>=
model.path1 <- "models/Sample Models/Chemistry & Physics/GasLab"
model.path2 <- "GasLab Free Gas.nlogo"
NLLoadModel(paste(nl.path, model.path1, model.path2, sep = "/"))
NLCommand("set number-of-particles 500", "no-display", "setup")
@

Next, we run the simulation for 40 times of 50 ticks (= 2000 ticks), save the speed of the particles after every 50 ticks, and flatten the list of lists (one list for each of the 40 runs) to one big vector:
<<label=sec_ApplExample_GasLab_NLDoReport>>=
particles.speed <- NLDoReport(40, "repeat 50 [go]", 
                              "[speed] of particles")
particles.speed.vector <- unlist(particles.speed)
@

To calculate the analytical distribution, we have to solve the following equations:

\begin{equation}
%B(v) = v \cdot e^{\frac{-m v^{2}}{2 k T}}
B(v) = v \cdot e^{(-m \cdot v)^2 \cdot (2 \cdot k \cdot T)^{-1}}
\label{B_v}
\end{equation}

\begin{equation}
normalizer = \int^{\infty}_{0}B(v)\ dv
\label{normalizer}
\end{equation}

\begin{equation}
B(v)_{normalized} = \frac{B[v]}{normalizer}\ \ for\ v = [0, \max(speed)]
\label{B_v_normalized}
\end{equation}

Now, \proglang{Yacas}/\pkg{Ryacas} will be used. For this, we define Equation~\ref{B_v} with the mean energy derived from the \proglang{NetLogo} simulation. We then define the normalizer integral and solve it numerically. 

We start by loading the \pkg{Ryacas} package:
<<label=sec_ApplExample_GasLab_load-package>>=
library("Ryacas")
@

We can install \proglang{Yacas}, if currently not installed (only for Windows - see \pkg{Ryacas}/\proglang{Yacas} documentation for other systems) with:
<<label=sec_ApplExample_GasLab_initYacas, eval=FALSE>>=
yacasInstall()
@

Next, we get the mean energy from the \proglang{NetLogo} simulation and define the function \code{B} and register it in \proglang{Yacas}:
<<label=sec_ApplExample_GasLab_NLReport, results=hide>>=
energy.mean <- NLReport("mean [energy] of particles")
B <- function(v, m = 1, k = 1) 
              v * exp((-m * v^2) / (2 * k * energy.mean))
yacas(B)
@

Then, we define the integral of function \code{B} from 0 to infinity and register the integral expression in \proglang{Yacas}:
<<label=sec_ApplExample_GasLab_integrate-B, results=hide>>=
B.integr <- expression(integrate(B, 0, Infinity))
yacas(B.integr)
@

Now, we calculate a numerical approximation using \proglang{Yacas}'s function \code{N()} and get the result from \proglang{Yacas} in \proglang{R} (the result is in column \code{value}):
<<label=sec_ApplExample_GasLab_normalize-B>>=
normalizer.yacas <- yacas(N(B.integr))
normalizer <- Eval(normalizer.yacas)
print(normalizer$value)
@

In a further step, we calculate the theoretical probability values of particle speeds using Equation~\ref{B_v}. We do this from 0 to the maximum speed observed in the \proglang{NetLogo} simulation.  

First, we get the maximum speed from the \proglang{NetLogo} simulation:
<<label=sec_ApplExample_GasLab_get-max-speed>>=
maxspeed <- max(particles.speed.vector) 
@

Next, we create a sequence vector from 0 to \code{maxspeed}, by \code{stepsize}, and calculate the theoretical values at the points of the sequence vector:
<<label=sec_ApplExample_GasLab_sequence>>=
stepsize <- 0.25
v.vec <- seq(0, maxspeed, stepsize)
theoretical <- B(v.vec) / normalizer$value
@

At the end, we plot the empirical/simulation distribution together with the theoretical distribution of particle speeds (Figure~\ref{fig:figmaxwellPlot}):

<<label=sec_ApplExample_GasLab_hist-line-particle-speed, fig=FALSE, include=FALSE>>=
hist(particles.speed.vector, breaks = max(particles.speed.vector) * 5, 
     freq = FALSE, xlim = c(0, as.integer(maxspeed) + 5), 
     ylab = "density", xlab = "speed of particles", main = "")
lines(v.vec, theoretical, lwd = 2, col = "blue")
@
<<label=sec_ApplExample_GasLab_hist-line-particle-speed_hidden, fig=TRUE, width=8, height=6, include=False, echo=FALSE>>=
par.default <- par(no.readonly = TRUE)
par(mar = c(3.4, 3.3, 0.5, 0.5))
par(xpd = T)
par(cex = 1.5)
hist(particles.speed.vector, breaks = max(particles.speed.vector) * 5, 
     freq = FALSE, ylab = "", 
     xlab = "", main = "", xlim = c(0, 40), ylim = c(0.0, 0.1))
lines(v.vec, theoretical, lwd = 2.5, col = "blue")
title(xlab = "speed of particles", mgp = c(2.2, 0, 0))
title(ylab = "density", mgp = c(2.2, 0, 0)) 
par(par.default)
@
  
\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{./images/-sec_ApplExample_GasLab_hist-line-particle-speed_hidden} \hfill
  \caption{Empirical probability distribution of particle speeds generated by the agent-based model (bars) with the theoretical Maxwell-Boltzmann distribution (blue line).}
  \label{fig:figmaxwellPlot}
\end{figure}

\subsection[Advanced plotting functionalities]{Advanced plotting functionalities}
\label{sec:advancedPlotting}

\proglang{R} and its packages deliver a wide variety of plotting capabilities. As an example, we present a three-dimensional plot in combination with a contour map.
We use the Urban Site - Sprawl Effect model \citep{Felsen2007} from \proglang{NetLogo}'s Models Library. This model
simulates the growth of cities and urban sprawl. Seekers (agents) look for patches with high attractiveness and also increase the attractiveness of the patch they stay on. Therefore, the attractiveness of the patches is a state variable of the model, which can be plotted in \proglang{R}. 

First, we initialize the \pkg{RNetLogo} package (if not already done) and load the model:
<<label=sec_ApplExample_AdvPlot_init, eval=FALSE>>=
library("RNetLogo")
nl.path <- "C:/Program Files/NetLogo 5.0.4"
NLStart(nl.path, gui = FALSE)
model.path <- "models/Curricular Models/Urban Suite"
model.name <- "Urban Suite - Sprawl Effect.nlogo"
NLLoadModel(paste(nl.path, model.path, model.name, sep = "/"))
@
<<label=sec_ApplExample_AdvPlot_loadModel_hidden, echo=FALSE, results=hide>>=
model.path <- "models/Curricular Models/Urban Suite"
model.name <- "Urban Suite - Sprawl Effect.nlogo"
NLLoadModel(paste(nl.path, model.path, model.name, sep = "/"))
NLCommand("random-seed 2147483647")
@

We resize \proglang{NetLogo}'s World and set the parameter values:
<<label=sec_ApplExample_AdvPlot_set-parameters>>=
NLCommand("resize-world -20 20 -20 20")
NLCommand("set smoothness 10",
          "set max-attraction 5",
          "set population 500",
          "set seeker-search-angle 200",
          "set seeker-patience 15",
          "set wait-between-seeking 5")
@

Then, we set up the simulation and run it for 150 ticks:
<<label=sec_ApplExample_AdvPlot_NLDoCOmmand>>=
NLCommand("setup")
NLDoCommand(150, "go")
@

Next, we get the value of the variable \code{attraction} from all patches as a matrix as well as the dimensions of \proglang{NetLogo}'s World:
<<label=sec_ApplExample_AdvPlot_get-results>>=
attraction <- NLGetPatches("attraction", as.matrix = TRUE)
pxcor <- NLReport(c("min-pxcor", "max-pxcor"))
pycor <- NLReport(c("min-pycor", "max-pycor"))
@

Now, we define the advanced plotting function with a three-dimensional plot and a contour map (adapted from \citet{Francois2011}):
<<label=sec_ApplExample_AdvPlot_define-plot-function, fig=FALSE, include=FALSE>>=
kde2dplot <- function(d, ncol = 50, zlim = c(0, max(z)), 
                      nlevels = 20, theta = 30, phi = 30)           
{
  z   <- d$z
  nrz <- nrow(z)
  ncz <- ncol(z)
  couleurs  <- tail(topo.colors(trunc(1.4 * ncol)), ncol)
  fcol      <- couleurs[trunc(z / zlim[2] * (ncol - 1)) + 1]
  dim(fcol) <- c(nrz, ncz)
  fcol      <- fcol[-nrz, -ncz]
  par.default <- par(no.readonly = TRUE)
  par(mfrow = c(1, 2), mar = c(0, 0, 0, 0), cex = 1.5)
  persp(d, col = fcol, zlim = zlim, theta = theta, phi = phi, 
        zlab = "attraction", xlab = "x", ylab = "y")
  
  par(mar = c(2, 2, 0.5, 0.5))
  image(d, col = couleurs)
  contour(d, add = TRUE, nlevels = nlevels)
  box()
  par(par.default)
}
@

We merge the data and execute the plot function (Figure~\ref{fig:threeD_plot}):
<<label=sec_ApplExample_AdvPlot_plot, fig=FALSE, include=FALSE>>=
d <- list(x = seq(pxcor[[1]], pxcor[[2]]),
     y = seq(pycor[[1]], pycor[[2]]),
     z = attraction)
kde2dplot(d)
@

<<label=sec_ApplExample_AdvPlot_plot_hidden, fig=TRUE, include=False, echo=FALSE, height=6, width=9>>=
kde2dplot(d)
@  
 
\begin{figure}
  \centering
  \includegraphics[width=0.7\textwidth]{./images/-sec_ApplExample_AdvPlot_plot_hidden} \hfill
  \caption{Spatial distribution of attractiveness of patches after 150 simulation steps. 3D plot (left) and contour plot (right).}
  \label{fig:threeD_plot}
\end{figure}


\subsection[Time sliding visualization]{Time sliding visualization}
\label{sec:timeSlidingViz}

As agent-based models are often very complex, more than three dimensions could be relevant for their analysis. With the \pkg{RNetLogo} package it is possible to save the output of a simulation in \proglang{R} for every tick and then click through, or animate, the time series of these outputs, for example a combination of the model's View and distributions of state variables. As a prototype, we write a function to implement a timeslider to plot turtles. This function can be extended to visualize a panel of multiple plots by tick. With a slider we can browse through the simulation steps. To give an example, we use the Virus model \citep{Wilensky1998} from \proglang{NetLogo}'s Model Library to visualize the spatial distribution of infected and immune agents as well as boxplots of the time period of infection and the age in one plot panel. 

We first load the required package \pkg{rpanel} \citep{Bowman2007} and define a helper function to set the plot colors for the logical variables (sick, immune) of the turtles:
<<label=sec_ApplExample_TimeSlider_init, eval=FALSE>>=
library("rpanel")

color.func <- function(color.var, colors, timedata) {
  color <- NULL
  if (!is.null(color.var)) {
    index.color <- which(names(timedata) == color.var)
    color <- timedata[[index.color]]
    color[color == FALSE] <- colors[1]
    color[color == TRUE] <- colors[2]
  }
  return(color)
}
@

Next, we define the main function containing the slider and what to do if we move the slider. The input is a list containing data frames for every tick. When the slider is moved, we send the current position of the slider (i.e., the requested tick) to the plotting function, extract the corresponding data frame from the \code{timedata} list and draw a panel of four plots using this data frame. 
<<label=sec_ApplExample_TimeSlider_define-slider-function, eval=FALSE>>=
plottimedata <- function(timedata.list, x.var, y.var, boxplot.var1,
                         boxplot.var2, color.var1 = NULL, 
                         colors1 = "black", color.var2 = NULL, 
                         colors2 = "black", mains = NULL, ...) 
{
  timeslider.draw <- function(panel) {
    index.x <- which(names(timedata.list[[panel$t]]) == x.var)
    index.y <- which(names(timedata.list[[panel$t]]) == y.var)
    index.b1 <- which(names(timedata.list[[panel$t]]) == boxplot.var1)
    index.b2 <- which(names(timedata.list[[panel$t]]) == boxplot.var2)
  
    color1 <- color.func(color.var1, colors1, timedata.list[[panel$t]])
    color2 <- color.func(color.var2, colors2, timedata.list[[panel$t]])
  
    par(mfrow = c(2, 2), oma = c(0, 0, 1, 0))
    plot(timedata.list[[panel$t]][[index.x]],
         timedata.list[[panel$t]][[index.y]], 
         col = color1, main = mains[1], ...)
    plot(timedata.list[[panel$t]][[index.x]],
         timedata.list[[panel$t]][[index.y]], 
         col = color2, main = mains[2], ...)
    boxplot(timedata.list[[panel$t]][[index.b1]], main = mains[3])
    boxplot(timedata.list[[panel$t]][[index.b2]], main = mains[4])
    title(paste("at time ",panel$t), outer = TRUE)
    panel
  }
  panel <- rp.control()
  rp.slider(panel, resolution = 1, var = t, from = 1, 
            to = length(timedata.list), title = "Time", 
            showvalue = TRUE, action = timeslider.draw)
}
@

In the third step, we initialize and run the \proglang{NetLogo} simulation and collect the results into the \code{timedata} list. As mentioned above, we push a data frame containing the results of one tick into the \code{timedata} list. Here, we run 100 ticks and use the \code{NLGetAgentSet} function to collect data from the turtles.
<<label=sec_ApplExample_TimeSlider_run-simulation, eval=FALSE>>=
library("RNetLogo")
nl.path <- "C:/Program Files/NetLogo 5.0.4"
model.path <- "models/Sample Models/Biology/Virus.nlogo"
NLStart(nl.path)
NLLoadModel(paste(nl.path, model.path, sep = "/"))
NLCommand("setup")
nruns <- 100
timedata <- list()
for(i in 1:nruns) {
  NLCommand("go")
  timedata[[i]] <- NLGetAgentSet(c("who", "xcor", "ycor", "age",
                                   "sick?", "immune?", "sick-count"),
                                 "turtles")
}
@

In the last step, we collect the dimension of the \proglang{NetLogo} World to use it for the axis extent of the plot and define the colors used for the variables \code{sick} (\code{green = FALSE, red = TRUE}) and \code{immune} (\code{red = FALSE, green = TRUE}). Finally, we call the above-defined \code{plottimedata} function to create the timeslider. 

<<label=sec_ApplExample_TimeSlider_create-slider, eval=FALSE>>=
world.dim <- NLReport(c("(list min-pxcor max-pxcor)",
                        "(list min-pycor max-pycor)"))

colors1 <- c("green", "red")
colors2 <- c("red", "green")

plottimedata(timedata.list = timedata, x.var = "xcor", y.var = "ycor", 
             xlab = "x", ylab = "y", color.var1 = "sick?", 
             color.var2 = "immune?", boxplot.var1 = "sick-count", 
             boxplot.var2 = "age", colors1 = colors1, colors2 = colors2,
             mains = c("Sick", "Immune", "Sick-count", "Age"),
             xlim = world.dim[[1]], ylim = world.dim[[2]])
@

Then we can move the slider and the plot is updated immediately (Figure~\ref{fig:timeslider}).

\begin{figure}
  \centering \includegraphics{NLandR_TimeSlider}
  \caption{Timeslider example using the Virus model.}
  \label{fig:timeslider}
\end{figure}

\section[Pitfalls]{Pitfalls}
\label{sec:pitfalls}

\subsection[Amount of data]{Amount of data}
\label{sec:amountOfData}

Please note that we are not able to stop the execution of a \proglang{NetLogo} command without closing our \proglang{R} session. 
Therefore, it is a good idea to think about the amount of data which should be transformed. For example, if we use the \code{NLGetPatches} function with the standard settings of the Forest Fire model from \proglang{NetLogo}'s Models Library, we are requesting 63001 patch values. If we ask for the pxcor, pycor and pcolor values, we are requesting for $ 63001 \cdot 3 = 189003 $ values. All these values have to be transformed from \proglang{NetLogo} data type to \proglang{Java} and from \proglang{Java} to \proglang{R}. This may take a while. For technical reasons, we are not informed about the process of data transformation. Therefore, it looks like the program crashed, but if we are patient, the program will return with the result after some time. That's why it is always a good idea to test our code with a very small example (i.e., small worlds, low number of agents etc.).
As mentioned in subsection~\ref{sec:packageLoading}, \proglang{NetLogo} 5.0.x is much faster at transferring data than \proglang{NetLogo} 4.x.

\subsection[Endless loops]{Endless loops}
\label{sec:endlessLoops}

If we use the functions \code{NLDoCommandWhile} and \code{NLDoReportWhile}, we should double check our while-condition. Are we sure that the condition will be met some time? To prevent endless loops, these functions take an argument \code{max.minutes} with a default value of 10. This means that the execution of these functions will be interrupted if it takes longer than the submitted number of minutes. If we are sure that we don't submit something that will trigger an endless loop, we can switch off this functionality by using a value of 0 for the \code{max.minutes} argument. This will speed up the operation because the time checking operation will not be applied.

\subsection[Data type]{Data type}
\label{sec:dataType}

The general mapping of \proglang{NetLogo} data types to \proglang{R} data types in \pkg{RNetLogo} is given in Table~\ref{tab:datatypes}.
 
\begin{table}
\centering 
\caption{Mapping from \proglang{NetLogo} data types to \proglang{R} data types.}
\label{tab:datatypes}
\begin{tabular}{|l|l|}\hline
  \proglang{NetLogo} & \proglang{R} \\ \hline \hline
  Boolean & Boolean \\
  String & String \\
  Number & Double \\
  List of Strings & Vector of Strings \\
  List of Booleans & Vector of Booleans \\
  List of Numbers & Vector of Doubles \\
  Nested List (one nesting) & List of Vectors \\
  Nested List (multi-level nesting) & List of Lists, lowest level: Vectors \\ \hline                 
\end{tabular}
\end{table}

We should think about the data types we are trying to combine. For example, an \proglang{R} vector takes values of just one data type (e.g., String, Numeric/Double or Logical/Boolean) unlike a \proglang{NetLogo} list, which can contain different data types.
Here are some examples.

First, we get a \proglang{NetLogo} list of numbers:
<<label=sec_Pitfalls_DataType_NLReport1, eval=FALSE>>=
NLReport("(list 24 23 22)")
@

Second, we get a \proglang{NetLogo} list of strings:
<<label=sec_Pitfalls_DataType_NLDoReport2, eval=FALSE>>=
NLReport("(list \"foo1\" \"foo2\" \"foo3\")")
@

Third, we try to get a \proglang{NetLogo} list of combined numbers and string:
<<label=sec_Pitfalls_DataType_NLDoReport3, eval=FALSE>>=
NLReport("(list 24 \"foo\" 22)")
@

The first two calls of \code{NLReport} will run as expected but the last call will throw an error, because \code{NLReport} tries to transform a \proglang{NetLogo} list into an \proglang{R} vector, which will fail due to the mixed data types. This is also very relevant for the columns of \code{data.frames}. 

\subsection[Data structure]{Data structure}
\label{sec:dataStructure}

Since \pkg{RNetLogo} does not restrict how \proglang{NetLogo} reporters are combined, it is very flexible but makes it necessary to think very carefully about the data structure that will be returned. How a \proglang{NetLogo} value is transformed in general is already defined in Table~\ref{tab:datatypes}.

But this becomes more complex for iteration functions like \code{NLDoReport} where the return values of one iteration are combined with the results of another iteration, especially when requesting the result as a data frame instead of a list.

For example, it makes a difference in the returned data structure when we request two values as a \proglang{NetLogo} list or as two single reporters in a vector (Table~\ref{tab:datastructure1}). Requesting the values as a \proglang{NetLogo} list returns a top-level list containing a vector of two values for all requested iterations. Requesting two single reporters returns these in a list as an entry of a top-level list. Therefore, this results in a nested list structure. There is not a wrong or preferred solution, it just depends on what we want to do with the result. 

\begin{table}
\centering 
\caption{Examples of results of \code{NLDoReport} with different \proglang{NetLogo} data structures. The Forest Fire model is used with a world of only 3 x 3 patches and a density of 99 percent. The model is reset before each example.}
\label{tab:datastructure1}
\begin{tabular}{|p{7cm}| p{7cm}|} \hline
  Call & Output of \code{str(<Call>)} \\ \hline \hline
  \code{NLDoReport(2, "go",} \newline \code{"(list count fires count embers)")} & \code{List of 2} \newline
   \code{\$ : num [1:2] 2 2} \newline
   \code{\$ : num [1:2] 0 4} \\
  & \\
  \code{NLDoReport(2, "go",} \newline \code{c("count fires", "count embers"))} & \code{List of 2} \newline
    \code{\$ :List of 2} \newline
    \code{ ..\$ : num 2} \newline
    \code{ ..\$ : num 2} \newline
    \code{\$ :List of 2} \newline
    \code{ ..\$ : num 0} \newline
    \code{ ..\$ : num 4} \\
  \hline
\end{tabular}
\end{table}

Requesting the result of \code{NLDoReport} as a data frame converts the top-level list to a data frame in a way that the top-level list entries become columns of the data frame and one iteration is represented by a row. This becomes problematic when nested \proglang{NetLogo} lists are requested (Table~\ref{tab:datastructure2}). In such a case, the nested \proglang{NetLogo} lists are transformed into \proglang{R} lists and the resulting data frame contains lists in its columns. 
Such a data structure is a valid, but uncommon, data frame and some functions, like \code{write.table}, can operate only with a data frame that contains just simple objects in its columns. To make a data frame with nested lists fit for functions like \code{write.table} we have to use the \code{I(x)} function for the affected columns to treat them 'as is' (see \code{help(I)} for details, e.g. \code{my.df$col1 <- I(my.df$col1)}). 

\begin{table}
\centering 
\caption{Examples of results of \code{NLDoReport} with different \proglang{NetLogo} data structures. The Forest Fire model is used with a world of only 3 x 3 patches and a density of 99 percent. The model is reset before each example.}
\label{tab:datastructure2}
\begin{tabular}{|p{7cm}| p{7cm}|} \hline
  Call & Output of \code{str(<Call>)} \\ \hline \hline
  \code{NLDoReport(2, "go",} \newline \code{"(list count fires count embers)",} \newline \code{as.data.frame=TRUE)} & \code{'data.frame':  2 obs. of  2 variables:} \newline
    \code{\$ X1: num  0 0} \newline
    \code{\$ X2: num  4 4} \\
	& \\
  \code{NLDoReport(2, "go",} \newline \code{c("count fires", "count embers"),} \newline \code{as.data.frame=TRUE)} & \code{'data.frame':  2 obs. of  2 variables:} \newline
    \code{\$ X1: num  0 0} \newline
    \code{\$ X2: num  4 4} \\
	& \\
  \code{NLDoReport(2, "go",} \newline \code{c("count turtles",} \newline \code{"(list count fires count embers)"),} \newline \code{as.data.frame=TRUE)} & \code{'data.frame':  2 obs. of  2 variables:} \newline
    \code{\$ X1: num  4 4} \newline
    \code{\$ X2:List of 2} \newline
    \code{ ..\$ : num  0 4} \newline
    \code{ ..\$ : num  0 4} \\
	\hline
\end{tabular}
\end{table}

Furthermore, using an agentset in an \code{NLDoReport} iteration with data frame return value can become problematic. As long as the number of members of the agentset does not change, it can be requested without problems in a data frame. The data frame contains one column for each agent and one row for each iteration. If the number of agents changes during the iterations the resulting data frame is not correct as it contains entries that do not exist. The number of columns equals the maximum number of agents over all iterations. For these iterations that contain less agents the columns of the data frame are filled with copied information from a former column. In short, the information is wrong.
The following example illustrates this. The Forest Fire model is used with a world of only 5 x 3 patches. 

<<label=sec_Pitfalls_DataStructure_startForestFire_hidden, echo=False, results=hide>>=
# load and reconfigure the forst fire model, this is unvisible
model.path <- "models/Sample Models/Earth Science/Fire.nlogo"
NLLoadModel(paste(nl.path, model.path, sep = "/"))
NLCommand("resize-world 0 4 0 2")
NLCommand("random-seed 3452134")
NLCommand("setup")
wa <- getOption("warn")
options(warn=-1)
@
<<label=sec_Pitfalls_DataStructure_NLDoReport_Turtles>>=
res <- NLDoReport(3, "go", "[who] of turtles", as.data.frame=TRUE)
str(res)
@
<<label=sec_Pitfalls_DataStructure_resetOptions_hidden, echo=FALSE, results=hide>>=
options(warn=wa)
@

The first iteration contains four turtles, the second five and the third seven turtles. The returned data frame therefore contains seven columns. Entries in columns for the first and the second row (i.e. iteration) are repeated from the first columns. But fortunately we are warned by \proglang{R} that the length of the vectors differ.
When we cannot be sure that the number of return values is always the same over the iterations we should use the default list data structure instead of the data frame return structure. Furthermore, if we want to request an agentset, we should better use the \code{NLGetAgentSet} function in an \proglang{R} loop, as shown in subsection~\ref{sec:timeSlidingViz}, because it returns the requested values in a sorted order; for agents by their \code{who} number and in case of patches from upper left to lower right.

These examples illustrate that it is necessary to think about the data structure that is required for further analyses and which function can process such a data structure. 

\subsection[Working directory]{Working directory}
\label{sec:workingDirectory}

We should avoid changing the working directory of \proglang{R} manually, because \proglang{NetLogo} needs to have the working directory pointed to its installation path. As 
the \proglang{R} working directory and the \proglang{Java} working directory depend on each other, changing the \proglang{R} working directory can result in unexpected behavior of \proglang{NetLogo}.
Therefore, we should use absolute paths for I/O processes in \proglang{R} instead of submitting \code{setwd(...)}. Note that the \pkg{RNetLogo} package changes the working directory 
automatically when loading \proglang{NetLogo} and changes back to the former working directory when the last active \proglang{NetLogo} instance is closed with \code{NLQuit}.

\section[Discussion]{Discussion}
\label{sec:discussion}

This article gave a theoretical and practical introduction to the \pkg{RNetLogo} package. The reader should be well-prepared to start his/her own projects based on \pkg{RNetLogo} after studying the examples. Since there are so many interesting packages available in \proglang{R} with connections to many other programs, it is really amazing what this connection offers to both, \proglang{R} users and \proglang{NetLogo} users.

Note that there are code samples for all functions in the example folder (\code{RNetLogo/examples/ code\_samples}) of the \pkg{RNetLogo} package. Furthermore, there are some example applications in the example folder, similar to those presented here. 

As presented the \pkg{RNetLogo} package successfully links the statistical computing environment \proglang{R} with the agent-based modeling platform \proglang{NetLogo}. Thereby it brings together the world of statistics and data analysis with the world of agent-based modeling. From the viewpoint of an \proglang{R} user it opens the possibility to access a rule-based modeling language and environment. Therefore, (nearly) all types of agent-based and system-dynamics models can be easily embedded into \proglang{R}. \proglang{NetLogo}'s Models Library gives a nice impression of what kind of models can be built, from deterministic to stochastic, from non-spatial to spatial models, from 2D to 3D, from cellular automata over network models and artificial neural networks to L-Systems and many other more. 

Bringing simulation models to \proglang{R} is not entirely new. 
There are, on the one hand, other modeling environments, like \proglang{RePast} \citep{North2006}, that open the possibility to send data to \proglang{R}. But the ability to control simulation experiments from \proglang{R} is new for such modeling tools. \proglang{NetLogo} was selected because it is very easy to learn, very well designed, and much better documented than other ABM platforms. It has a very active user community and seems to be the most appropriate basis for all kinds of modelers, from beginners to professionals and from ecology over social sciences to informatics.
On the other hand, there are packages available to build simulation models directly in \proglang{R}, like \pkg{simecol} \citep{Petzoldt2007}. Especially \pkg{simecol} is fast and very flexible and a good choice in comparison to implementations in pure \proglang{R} but it does not provide specific support for making model development and simulation efficient as agent-based model environments like \proglang{NetLogo} and \proglang{RePast} do.   

Some first use-cases of \pkg{RNetLogo} have been presented in this article. Beside the advanced visualization possibilities and connections to other software an important application area is the design and analysis of simulation experiments in a systematic, less ad hoc, way. \proglang{R} delivers all necessary functions of the Design of Experiments (DoE) principles. With \pkg{RNetLogo} the technical connection between all kinds of DoE and ABM is available.

There are already ready-to-use solutions for model analysis/DoE techniques available for agent-based modeling, like \proglang{BehaviorSearch} \citep{Stonedahl2013}, \proglang{MEME} \citep{Ivanyi2007}, and \proglang{openMOLE} \citep{Reuillon2010}, but they are less flexible and adaptable than \proglang{R}. Often, for one task, several packages in \proglang{R} are available and if not, writing own functions is flexible and fast, especially because many scientists know \proglang{R} for data analysis. Since \pkg{RNetLogo} does not restrict the user to predefined analysis functions it opens a large flexibility. But \pkg{RNetLogo} can only check the submitted \proglang{NetLogo} code strings at runtime. This is a disadvantage, although the \proglang{NetLogo} code strings are typically simple and lack of automated checking encourages well-designed analysis. Nevertheless, \pkg{RNetLogo} requires the user to understand data types and structures of both \proglang{NetLogo} and \proglang{R}.

\pkg{RNetLogo} pushes the documentation and therefore the reproducibility of agent-based modeling studies, a key feature of science, to a new level. Using \pkg{RNetLogo} in conjunction with tools like \pkg{Sweave} \citep{Leisch2002}, \pkg{odfWeave} \citep{Kuhn2010} or \pkg{SWord} \citep{Baier2009} will contribute to the right track to replicability and reproducibility of agent-based simulation studies by automatic and self-documented report generation. 
For example, \pkg{Sweave} can embed \proglang{R} code in a \proglang{LaTeX} text document. When compiling the \pkg{Sweave} document, the \proglang{R} code is evaluated and the results (not only numeric but also images) can be embedded automatically in the \proglang{LaTeX} document. The \pkg{RNetLogo} package opens the possibility to embed not only results of \proglang{R}, but also the result of a \proglang{NetLogo} simulation. We can create a self-documented report with \proglang{NetLogo} simulations and \proglang{R} analytics (with or without source code). For an example see the Sweave code of this article. 

Since models become more complex their computational requirements are increasing as well. A lot of these requirements are compensated by increasing computational power, but the use of modern model development and analysis techniques for stochastic models, like Bayesian calibration methods, make a large number of repeated simulations necessary. Using \pkg{RNetLogo} includes, of cause, an overhead when converting model results from \proglang{NetLogo} to \proglang{R} and vice versa, but there are already techniques available to spread such repetitions to multi-cores and computer clusters (see the \pkg{RNetLogo} package vignette \href{http://cran.r-project.org/web/packages/RNetLogo/vignettes/parallelProcessing.pdf}{Parallel Processing with \pkg{RNetLogo}}). 

To sum up, I expect that this contribution will make agent-based modeling with \proglang{NetLogo} more popular and easier in the \proglang{R} community and will support the methodological developments towards rigorous model development, testing and analysis in the ABM community. 

\section*{Acknowledgements}
I would like to thank two anonymous reviewers as well as Volker Grimm and Winfried Kurth for their very valuable comments on an earlier version of the manuscript. 
\bibliography{refs}

<<label=postprocess_quit_hidden, echo=False, results=hide>>=
NLQuit(nl.obj = my.netlogo3)
NLQuit(nl.obj = my.netlogo2)
NLQuit(nl.obj = my.netlogo1)
NLQuit() 
@

\end{document}
